<!DOCTYPE html>
<html layout:decorate="~{layout}">
<body>
	<div layout:fragment="content" class="container">
		<form method="post" th:object="${boardForm}">
			<input type="hidden" th:name="${_csrf.parameterName}"
				th:value="${_csrf.token}" id="_csrf" />
			<div th:replace="~{form_errors :: formErrorsFragment}"></div>
			<div class="mb-3">
				<label for="subject" class="form-label">제목</label> <input
					type="text" th:field="*{subject}" class="form-control">
			</div>
			<div class="mb-3">
				<label for="content" class="form-label">내용</label>
				<div id="content" name="content" class="form-control"></div>
				<input type="textarea" name="content" id="ecp" hidden> <input
					type="hidden" id="ecp1" th:field="*{content}">
			</div>
			<input type="submit" value="저장" class="btn btn-primary my-2">
		</form>
	</div>
	<script layout:fragment="script" type="text/javascript"
		th:inline="javascript">

		const editor = new toastui.Editor({
			el : document.querySelector('#content'), // 에디터를 적용할 요소 (컨테이너)
			height : '500px', // 에디터 영역의 높이 값 (OOOpx || auto)
			initialEditType : 'markdown', // 최초로 보여줄 에디터 타입 (markdown || wysiwyg)
			initialValue : '',
			previewStyle : 'vertical', // 마크다운 프리뷰 스타일 (tab || vertical)
			  hooks: {
				   async addImageBlobHook(blob, callback) { // 이미지 업로드 로직 커스텀
					   
					   try {
		                    /*
		                     * 1. 에디터에 업로드한 이미지를 FormData 객체에 저장
		                     *    (이때, 컨트롤러 uploadEditorImage 메서드의 파라미터인 'image'와 formData에 append 하는 key('image')값은 동일해야 함)
		                     */
		                    const formData = new FormData();
		                    formData.append('image', blob);

		                    
		                    console.log("DDDDDDDDDDDDDDDDDDDDDDDDDDDD :: ");
		                    
		                    //?${_csrf.parameterName}=${_csrf.token}
		                    // 2. FileApiController - uploadEditorImage 메서드 호출
		                    const response = await fetch('/tui-editor/image-upload', {
		                        method : 'POST',
		                        body : formData,
		                        headers: {
		                        	 'X-CSRF-Token':  $('#_csrf').attr('value')
		                        }, // 추가된 헤더 적용
		                    });

		                    // 3. 컨트롤러에서 전달받은 디스크에 저장된 파일명
		                    const filename = await response.text();
		                    
		                    console.log("filename :: " + filename);
		                    
		                
// 		                    console.log('서버에 저장된 파일명 : ', filename);

		                    // 4. addImageBlobHook의 callback 함수를 통해, 디스크에 저장된 이미지를 에디터에 렌더링
		                    const imageUrl = `/tui-editor/image-print?filename=${filename}`;
		                    callback(imageUrl, 'image alt attribute');

		                } catch (error) {
		                    console.error('업로드 실패 : ', error);
		                }
		
			    	  
			    	
			      },
			    },
			//addImageBlobHook :null,
// 			toolbarItems : [ [ 'heading', 'bold', 'italic', 'strike' ],
// 					[ 'hr', 'quote' ],
// 					[ 'ul', 'ol', 'task', 'indent', 'outdent' ],
// 					[ 'table', 'link' ], [ 'code', 'codeblock' ] ],
			placeholder : '내용을 입력해 주세요.',
		});

		
		const onUploadImage = async (blob, callback) => {
			 console.log(blob);
			
// 		    const url = await uploadImage(blob);
// 		    callback(url, 'alt text');
		    return false;
		  };
		
		editor.setMarkdown(document.querySelector('#ecp1').value);

		document.querySelector('form').addEventListener('submit',
				function(event) {
					document.querySelector('#ecp1').value = '';

					const content = editor.getMarkdown();
					const encodedC = encodeURIComponent(content);

					document.querySelector('#ecp').value = encodedC;
				});
	</script>
</body>
</html>